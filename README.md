DataStructures
==================================

该文件用来展现数据结构与算法的学习思路

****

|Autor|Kartoffel-chen|
|:---:|:---:
|E-mail|1414524058@qq.com

****

## 目录

* [稀疏数组](#稀疏数组)

* [队列](#对列)
    * 队列
    * 环形队列
    
* [单向链表](#单向链表)

* [双向链表](#双向链表)

* [约瑟夫问题](#约瑟夫问题)

* [栈](#栈)
    * 模拟计算器
    * 逆波兰表达式
    
* [递归](#递归)
    * 迷宫回溯
    * 八皇后问题
    

    
* [排序算法](#排序算法)
    * 内部排序
    * 外部排序
    
* [算法事件复杂度](#算法事件复杂度)

* [内部排序](#内部排序)
    * [冒泡排序](#冒泡排序)
    * [选择排序](#选择排序)
    * [插入排序](#插入排序)
    * [希尔排序](#希尔排序)
        * 交换法
        * 位移法
***

## 内容

## **稀疏数组**

#### 应用场景

```

模拟围棋的存盘和读盘
   例如 : 下为棋盘
          其中0代表围棋中没有下子的位置
          1表示白子
          2表示黑子
0    0    0    0    0    0    0    0    0    1    0    0    0    0    0    
0    0    1    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    1    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    2    0    0    0    0    0    0    0    
0    0    2    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0 

```

#### 稀疏数组转换思路


1.存盘  
* 首先遍历棋盘得到有效值size(1或者2为有效值,代表有棋子的地方)  
* 创建大小为int[size + 1][3]
        1).稀疏数组创建规则
        2).第一行用来存放棋盘的[行数,列数,有效值个数]
        3).从第二行开始,用来存放有效值数据的信息[行坐标,列坐标,有效值]
* 将会得到下面的数组 例如 :

```
    12    15   5    ---> 代表棋盘的原本的行为12,列为15,期盼中有5个棋子
    0     9    1    ---> 代表原本棋盘的arr[0][9] = 1;
    1     2    1    ---> 同上
    5     6    1    
    6     7    2    
    7     2    2 
```
2.读盘   
* 首先遍历稀疏数组读取第一行的信息,对原本棋盘进行还原   
````
   例如 : 读取到 12 15 ,并且 int[][] test = new int[12][15];   
````
* 然后对以下行的数据进行对应还原   
````
   例如 : test[0][9] = 1;   
   例如 : test[6][7] = 2;   
````
***

## **对列**

#### 队列的应用场景
```

银行服务系统
例如:
    银行有5个柜台,能一次服务五个人
    银行最大能装人数
    每次服务结束,这个人退出银行,银行就能继续添加人进来(也可以不加)    

```

#### 队列思路分析
* 队列本身是有序列表
* 创建一个队列,接受最大容量(银行能服务多少人)
* 需要两个指针分别指向队列的头的前一个位置和尾巴
* 当往列表添加"人"的时候,尾巴向后移动一位
* 服务结束退出"人"的时候,把队列头的前一个位置指向第一个位置,输出
* 当头等于尾时,说明队列空了

#### 弊端   
此队列只能使用一次,应为我们的两个辅助指针并不会重复指向 0~最大服务数
,此时就引出了环形队列

## **环形队列**

#### 环形队列思路
* 在有序列表的基础上对头指针和尾指针进行改良
* 此时,我们的头指针都指向第一个元素,初始化为 front = 0
* 尾指针指向第一个元素的下一个元素,初始化也为 rear = 0
* 添加元素是,尾指针后移,并且做一个取模操作,保证rear能够回到原点    
````
    例如 : 队列的最大值为3
    添加第一个元素时,rear = (rear + 1) % 3 此时rear = 1;   
    添加第二个元素时,rear = (rear + 1) % 3 此时rear = 2;
    添加第三个元素时,rear = (rear + 1) % 3 此时rear = 3;
    添加第四个元素时,rear = (3 + 1) % 3 此时rear = 1;
    由此回到最开始的地方
````
* 取出元素同理由
* 当然,显示队列时候我们就应该从头指针指向的数据开始遍历,遍历结束条件是 if <有效数据
* 有效数据应该等于 (rear + maxsize - front) % maxsize
```
    例如 : 队列的最大值为3
    此时rear = 1 , front = 2;
    (1 + 3 - 2) % 3 = 2;
    有效数据就应该为2
```
* 循环条件就该写为for(i = front ; i < front + 2 ; i ++)
***

## **单向链表**

#### 创建链表
```
例如: 
    class Node{
        int id
        Node next;  ---> 指向下一个节点
    }
```

### 节点管理

#### 1.插入节点
* 在尾节点插入
    * 首先借助一个辅助指针,遍历这个链表,让指针指向链表的最后一个节点
    * 然后把最后一个节点的next域,指向新加入的节点
* 按照某一顺序插入(按照id大小排序)
    * 借助temp指针,遍历链表,当temp.next.id < newNode.id时候,说明就是添加到temp后
    * 把新增节点的next指向之前temp的next
    * 把temp的next指向新增节点

#### 2.修改节点信息
* 按照(id或其他修改)
    * 依然借助辅助指针遍历链表找到需要修改的链表,然后进行修改

#### 3.删除节点信息
* 按照(id或其他删除)
    * 依然借助辅助指针遍历链表找到需要删除的节点,此时的辅助指针应该指向下一个节点
    * 说明:当我们想要删除第三个数据时,我们的指针指向第二个节点,而指针的next刚好指向第三个节点,
    然后把第二个节点的下一个节点,指向第三个节点的下一个节点
    ```
        temp.next = temp.next.next;
    ```

***
## **双向链表**

#### 创建链表
```
例如: 
    class Node{
        int id
        Node pro;   ---> 指向前一个节点
        Node next;  ---> 指向下一个节点
    }
```

### 节点管理

#### 1.插入节点
* 在尾节点插入
    * 首先借助一个辅助指针,遍历这个链表,让指针指向链表的最后一个节点
    * 把最后一个节点的next域,指向新加入的节点
    * 把新加入的节点的pro,指向上一个节点
* 按照某一顺序插入(按照id大小排序)
    * 借助temp指针,遍历链表,当temp.next.id < newNode.id时候,说明就是添加到temp后
    * 把新增节点的next指向之前temp的next
    * 把新增节点的pro指向temp
    * temp的next指向新增节点
 ```
      studentNode.next = temp.next;
      studentNode.pro = temp;
      temp.next = studentNode;
 ```

#### 2.修改节点信息
* 按照(id或其他修改)
    * 依然借助辅助指针遍历链表找到需要修改的链表,然后进行修改

#### 3.删除节点信息
* 按照(id或其他删除)
    * 相比单项链表,双向链表删除节点只需要找到当前满足条件的节点
    * 找到temp的id 等于需要删除的节点的id
    * 把当前节点的上一个节点的next,指向当前节点的下一个节点
    * 把当前节点的下一个节点的pro,指向当前节点的上一个节点
    
 ```
    temp.pro.next = temp.next;
    temp.next.pro = temp.pro;
 ```
 #### 重点!!!
 ```
    这里存在一个可能出现的空指针异常
    当我们temp为最后一个节点的时候,temp就不存在next,所以需要对其进行判断
    
    temp.pro.next = temp.next
    //对节点进行判断
    if(temp.next != null){   //如果不是最后一个就执行这条命令
        temp.next.pro = temp.pro;
    }

```

***

## **约瑟夫问题**

#### 应用场景
```
  小孩丢手绢,丢到的出列
  例如 : 
    1  ~ 5 号小孩手拉手
    我指定第二个小孩出列,那第一个小孩就应该拉向第三个小孩,
    继续形成一个环装
```

#### 思路分析
* 创建小孩拉小孩的环境
    * 创建一个空的头节点 first = null;
    * 当开始创建节点时,判断是不是创建的第一个节点,如果是赋值给first
    * 并把第一个节点的下一个节点指向此节点,然后借助辅助指针
    ```
         first = boy;
         first.setNext(first);   // 构成一个环状
         temp = first;   
    ```
    * 如果不是第一个节点,就借助temp
    ```
        temp.setNext(boy);
        boy.setNext(first);
        temp = boy;
    ```
 * 创建小孩出列环境
    * 首先借助一个辅助指针来指向最后一个小孩
    * 需要进行遍历 当last.next = first,时候满足条件
    * 接收需要从第几个小孩开始出列,并且把first指向需要出列的小孩(借助遍历)
    * 例如 : 需要第三个小孩作为第一个小孩出列,用for循环三次
    ``` 
         for (int i = 0; i < 3 - 1; i++) {   // 循环三此
            first = first.getNext();
            last = last.getNext();
        }
    ```
    * 从这里开始出列 使用循环
    * first = first.next;
    * last = last.getNext();
    * 最后会留下一个小孩存在此队列,把他输出
    
***

## **栈**

#### 特性
```` 先进后出 ````

#### 用链表模拟栈

思路 :
* 首先创建一个单项链表
* 每个节点包含不同属性值以及下一个节点的next域
* 添加元素方式为在链表最后添加
* 取出元素方法为
* 每次取出前,借助辅助指针,遍历链表使得 temp.next.next = null;
* 返回temp.next的值,并且把temp.next指向null;
* 由此实现栈内存先进后出的特点


***
#### 模拟计算机(中缀表达式)

String num = "20/5*(2*4+1)+84";

#### 思路分析

* 创建两个栈,一个用于存放符号,一个用于存放数据
* 遍历中缀表达式
* 当遇到的时数字时后,压入数据栈
* 当遇到符号时
    * 判断符号栈是否为空,为空就直接入栈
    * 不为空,判断符号优先级,如果遍历到的符号优先级,小于栈顶的符号优先级
    * 弹出数据栈中栈顶以及次栈顶的数据,并且弹出符号栈栈顶的符号,对其进行运算
    * 结果压入数据栈,遍历到的符号压入符号栈
    ```
    s1栈 - + * 
    s2栈 2 4 5 6    
  
    此时遍历到符号为-号
    就弹出s2中的 6 5
    弹出s1 中的 * ,进行运算得到结果为 30 
    压入数据栈
    并且把遍历到的符号压入符号栈
    
    s1栈 - + -
    s2栈 2 4 30  
    ```
* 当遇到"(" 左括号时候(我的思路)
    * 从左括号的下一个位置开始遍历,做一个字符串拼接,直到遇到右括号为止
    * 把这个字符串传入到次方法中,做一个递归操作
    * 其中要注意的是,由于遍历字符串需要借助一个index,当遇到左括号以后,
    调用递归,等于说递归出来结果时index只加了一次,所以这里需要记录拼接的字符串长度给加上,同时两个括号也需要加入
    ```
    //往后遍历得到新的字符串直到遇到')'结束
    String newNumber = "";    // 用于字符串拼接
    while (arr[index + 1] != ')') {   // 不是右括号 循环
        char loop = arr[index + 1];   //因为(括号代表当前位置,所以从index + 1开始拼接
        newNumber = newNumber + loop;  //拼接
        index++;                       //每拼接一次 ++
    }  
    int res01 = res(newNumber);    
    index += 1;
    numberStack.push(res01);
    ```   
  
***
  
#### 逆波兰计算器(逆波兰表达式)
  String num = (3+5)*2+5   
  对应的后缀表达式应该是   
  String num = "3 5 + 2 * 5 +"
  
#### 计算思路
  * 首先把后缀表达式相对应的字符串做出相应的变化
    * 去掉空格(定义时候可以不加,则省略),遍历加入list集合中方便操作
    * 或者切割成一个数组,遍历加入list集合
    * 两个方法视情况而定
    * 对list中的数据遍历加入到stack栈中
    * 遍历list压栈的过程中
        * 如果遇到数字,直接压入栈中
        * 如果遇到符号,就弹出栈顶数据以及次栈顶数据
        * 进行运算,并且把计算结果压入栈
        * 直到list遍历到最后一个数据
        * 此时栈中就只有一个数据,此数据就为最终的计算结果
        
### 重难点:中缀表达式转后缀表达式

思路:
* 首先创建两个栈,一个符号栈s1,最终表达式栈s2
    * 这里有个注意点 : s2为最终表达式栈,而栈的特性是先进后出,所以当输出时候应该对其逆序输出
    * 所以这里我把最终表达式栈用list集合代表
* 遍历中缀表达式
```String num = (3+5)*2+5```
* 判断遍历到的字符
    * 如果遍历到数字,字节压入最终表达式栈s2
    * 如果是符号
        * 判断符号栈是否是空,为空压入栈
        * 不为空,判断栈顶符号与遍历到的符号优先级
        * 如果栈中符号优先级<=遍历符号优先级,入栈
        * 如果>的话就把遍历到的符号压入s2
    * 如果是(左括号,直接压入s1
    * 如果是)右括号,就依次弹出s1栈顶的数据,添加到s2,直到s1栈顶数据是(左括号
    * 然后 ```弹出(```这一步非常重要!!!!
    * 最终得到s2就是后缀表达式对应的list集合
    * 传入刚才定义好的后最表达式计算方法中
    
    
***
    
## **递归**

一个方法中,调用本身方法
例如 : 
```
public void 递归(int i){
    int i = 5;   
    if(i > 2){
        i = 递归(i-1);
    }
    System.out.println(i);
}
```
2 3 4 5
***

#### 迷宫问题
迷宫地图使用0 1来构成
例如 : 
```text
11111111111111111111111111111
12221011100100000000000000001
10121022201222000000000000001
10022221222212222222222222291
11111111111111111111111111111
```
1 表示墙   
0 表示可以走的路   
2 表示到达终点的线路   
9 表示迷宫重点  

#### 思路分析
* 创建一个小球移动方法setway,传入地图
* 小球初始位置(起点)
* 对小球当前位置进行判断
    * 如果小球当前位置为0,说明可以走,就把当前位置置为2
* 小球行走判断
    * 首先判断是否已经找到终点9
    * 如果没有找到
    * 使用规则 上--> 右--> 下--> 左
````
if (setWay(map, x + 1, y)) {         //小球上移动
    return true;
} else if (setWay(map, x, y + 1)) {  //小球右移动
    return true;
} else if (setWay(map, x - 1, y)) {  //小球下移动
    return true;
} else if (setWay(map, x, y - 1)) {  //小球左移动
    return true;
}else{
    //上下左右都走不通说明是死路
    map[x][y] = 3;
    return false;
}
````

***

#### 八皇后问题

问题说明
首先有一个8*8的棋盘,玩家需要给8个皇后(棋子)摆放位置,摆放保证每一行每一列都只存在一个皇后,并且每一皇后的斜线上也只能存在一个皇后

例如 : 
```text
0   0   0   1   0   0   0   0
0   1   0   0   0   0   0   0
0   0   0   0   0   0   0   0
0   0   0   0   0   0   1   0
0   0   1   0   0   0   0   0
0   0   0   0   0   1   0   0
0   0   0   0   0   0   0   1
0   0   0   0   1   0   0   0
1   0   0   0   0   0   0   0
```
0 表示棋盘位置   
1 表示皇后   
规则 : 每一行每一列每一条斜线都只能放一个皇后

#### 思路分析
* 首先我们使用一维数组表示皇后摆放位置
```
int[] queen = int[8];
上面摆放位置例子: 
queen = {0,4,7,5,2,6,1,3}
下表表示第几个皇后
值表示摆放位置
```
* 需要用到一个循环每次放入一个皇后
* 一个判断皇后是否能放入的方法judge(int n)
* 传入需要放置的第n个皇后
    * 用一个循环,次数为0 ~ 传入的皇后为第几个 n
    * 判断之前第 0 个(第一个) 与n皇后是否在同一排
    ```text
       for (int i = 0; i < n; i++) {
          //array[i] == array[n],判断是否在同一列
          //Math.abs(n-i) == Math.abs(array[n] - array[i]) , 判断是否在同一斜线

          //分析 : 假如现在加入的是第二个皇后 且位置是第三个 arr[1] = 2; n = 1;
          //       此时第一个皇后在第二个位置 array[0] = 1 ; i = 0;
          //       n - i = 1; arr[n] - arr[i] = 1; 所以不能放在这
          if(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i])){
              return false;
          }
       }
       return true;
    ```
    * ``array[i] == array[n]``判断是否在同一行
    * ``Math.abs(n-i) == Math.abs(array[n] - array[i])``判断是否在同一条斜线
      ```text
      假设第一个皇后放在第一排第一个位置   应该表示为 array(0) = 0;
      假设第二个皇后放在第一排第二个位置   应该表示为 array(1) = 1;
      1 - 0 == 1 - 0;
      满足说明在同一斜线,不满足
      ```
    * 当退出判断后,如果能放,继续放下一个皇后
    * 不能放,把此皇后位置后移一位,继续判断是否满足
    ```text
     for (int i = 0; i < max; i++) {
        //先把该皇后放在该行的第一列
        array[n] = i;
        //判断当放置第n个皇后于之前的皇后是否冲突
        if(judge(n)){   //你冲突
            check(n+1);
        }
        //如果冲突就继续循环,把皇后后移一个位置
     }
    ```
  
 * 当每次放完8个皇后后,输出这个数组
 
 ***
 
 ## **排序算法**
 
 #### 基本介绍
 排序也称排序算法,是将一组数据依照指定的顺序进行排序
 
 #### 分类
 * 内部排序: 将需要处理的所以数据加载到内部存储器中进行排序
 * 外部排序: 数据量过大,无法全部加载到内存中,欲借助外部存储器进行排序   
 
 #### 度量一个程序执行时间的两种方法
 * 事后统计的方法
 * 事前估算的方法   
    ``通过分析某个算法的时间复杂度来判断那个算法更优``
 
***

 ## **算法事件复杂度**
 
 #### **时间频度**
 基本介绍
 一个算法花费的时间与算法中语句的执行次数成正比,那个算法中语句执行次数多,花费的时间就多.
 执行次数称为语句频度过时间频度.``极为T(n)``

 ```text
    1.2n+20 和2n 随着n的变大,执行曲线无限接近,20可以忽略
    2.3n+10 和3n 随着n的变大,执行曲线无限接近,10可以忽略

    总结: 可以省略常数项
```

 ```text
    1.2n^2+3n+10 和 2n^2随着n变大,曲线无限接近,可以忽略3n+10
    1.n^2+5n+20 和 n^2随着n变大,曲线无限接近,可以忽略5n+20

    总结: 可以忽略低次项
```

```text
    1.随着n值的变大,5n^2+9n 和 3n^2+2n ,执行曲线重合,说明这种情况下,5和3可以忽略
    2.而n^3+5n 和 6n^3+4n,执行曲线分离,说明多少次方式关键

   总结 : 系数可以忽略
```
 
 #### 时间复杂度
 
 计算时间复杂度的方法:
 * 用常数1代替运行时间中的所有加法常数 ```(T(n)=3n^2+7n+6-----> T(n)=3n^2+7n+1)```
 * 修改后 的运行次数函数中,只保留最高项 ```(T(n)=3n^2+7n+1------> T(n)=3n^2)```
 * 取出最高阶项的系数 ```(T(n)=3n^2+7n+1------> T(n)=n^2 ----> O(n^2))```
 
 常见的时间复杂度
 ```text
    1.常数阶O(1)
    2.对数阶O(log2n)(2为底,n的对数)
    3.线性阶O(n)
    4.线性对数阶O(nlog2n)(n倍的2为底,n的对数)
    5.平方阶O(n^2)
    6.立方阶O(n^3)
    7.k次方阶O(n^k)
    8.指数阶O(2^n)(避免出现)
 ```

说明:
* 常见的算法时间复杂度由小到大一次为 : 上面的排序,数字越大随着n值越大效率越低
* 尽量避免出现指数阶

****

## **冒泡排序**

方法 : 对数组中相邻两个数据进行比较,逆序的话就交换其位置

例如: int[] arr = {-2,5,-1,8,6}

```text
小到大排序
第一次排序:
        -2 5 -1 8 6    ---> -2 和 5 比较,  不变
        -2 -1 5 8 6    ---> 5 和 -1 比较, -1 小 交换位置
        -2 -1 5 8 6
        -2 -1 5 6 8
第二次排序: 
        -2 -1 5 6 8
        -2 -1 5 6 8
        -2 -1 5 6 8
第三次排序:
        不变,应为已经排序好
第四次排序:
        不变
```

#### 结论
* 交换的次数是数组长度-1次,每次确定最后一个数最大或者最小值

#### 代码思路
* 需要进行两层循环
* 第一层循环,控制这个数组所要交换的次数
* 第二层循环,由于每次交换以后,都能确定最后一个数据,所以需要控制内层循环的次数
* 优化
* 如上图所示,当我们的排序进行到第二次时候,就已经排序完成,但是代码还是会继续往下执行
* 所以优化的目标就是控制当排序的次数

```
int temp = 0;
boolean flag = false;   //用来记录是否发生交换

for (int i = 0; i < arr.length - 1; i++) {   //
    for (int j = 0; j < arr.length - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {    // 从小到大排序
            flag = true;              //发生交换,置为true
            temp = arr[j];            //把当前数字据记录下来
            arr[j] = arr[j + 1];      //交换
            arr[j + 1] = temp;
        }
    }

    if (flag) {
        flag = false;      // 如果发生交换,把flag置为false,重新进行判断
    } else {
        break;             // 如果没有发生交换,跳出此次循环
    }
}
```
#### 冒泡排序运行时间测试

首先定义了8万个随机数组成的数组
```text
int[] arr = new int[80000];
for (int i = 0; i < 80000; i++) {
    arr[i] = (int)(Math.random() * 80000);           //1-8万的随机数据存入数组
}
```


* 没有优化前的运行时间
    ```text
    第一次测试
    排序前的时间是 : 2020-02-28 16:50:39
    排序后的时间是 : 2020-02-28 16:50:54
    第二次测试
    排序前的时间是 : 2020-02-28 16:52:21
    排序后的时间是 : 2020-02-28 16:52:36
    第三次测试
    排序前的时间是 : 2020-02-28 16:53:14
    排序后的时间是 : 2020-02-28 16:53:30
    ```
* 优化后
    ```text
    第一次测试
    排序前的时间是 : 2020-02-28 16:55:47
    排序后的时间是 : 2020-02-28 16:56:03
    第二次测试
    排序前的时间是 : 2020-02-28 16:56:23
    排序后的时间是 : 2020-02-28 16:56:39
    第三次测试
    排序前的时间是 : 2020-02-28 16:57:09
    排序后的时间是 : 2020-02-28 16:57:23
    ```
* 大概是15秒 优化的效果不是很明显,但是在实际中,优化确实能够节省资源浪费

***

## **选择排序**

方法 : 每次遍历数组,找到最小的值,交换位置
例如 : int[] arr = {6,8,4,0,-5,10}

```text
第一次交换 : -5 8 4 0 6 10  --> 确定 -5 为最小值
第二次交换 : -5 0 4 8 6 10  --> 确定 -5 0 的顺序
第三次交换 : -5 0 4 8 6 10  --> 确定 -5 0 4 的顺序
第四次交换 : -5 0 4 6 8 10
第五次交换 : -5 0 4 6 8 10
```

##### 结论
 交换次数依然是 数组长度-1   
 每次交换确定一个顺序

#### 代码思路

* 需要进行两层循环
* 第一层循环,控制这个数组所要交换的次数
* 第二层循环,由于每次交换以后,都能确定最后一个数据,所以需要控制内层循环的次数
* 内层循环中,每次假设第j个数据为最小值,与之后的数据进行比较,如果大于跳过,小于的话就赋值给最小值
```text
for (int i = 0; i < arr.length - 1; i++) {
    int minIndex = i;                 //假定最小值下标
    int min = arr[minIndex];          //假定第i个值为最小值

    for (int j = i + 1; j < arr.length - 1; j++) {
        if (arr[minIndex] > arr[j]) {
            min = arr[j];
            minIndex = j;
        }
    }
    //当循环退出 min就为找到的最小值,minIndex就是最小值下标

    arr[minIndex] = arr[i];   //交换位置
    arr[i] = min;
    }
    System.out.println(Arrays.toString(arr));
}
```

#### 选择排序运行时间

首先定义了8万个随机数组成的数组
```text
int[] arr = new int[80000];
for (int i = 0; i < 80000; i++) {
    arr[i] = (int)(Math.random() * 80000);           //1-8万的随机数据存入数组
}
```

* 运行测试
    ```text
    第一次测试
    排序前的时间是 : 2020-02-28 17:00:08
    排序后的时间是 : 2020-02-28 17:00:13
    第二次测试
    排序前的时间是 : 2020-02-28 17:00:45
    排序后的时间是 : 2020-02-28 17:00:50
    第三次测试
    排序前的时间是 : 2020-02-28 17:00:57
    排序后的时间是 : 2020-02-28 17:01:02
    ```
* 选择排序对8万个数据进行排序,用时5秒左右,相比冒泡排序确实快了很多

***

## **插入排序**

方法 : 把一个数组想成时两个数组,一个有序数组,一个无序数组,我们把无序数组中的数据插入到有序数组中,按照某一种大小规则来进行插入

例如 : int[] arr = {6,8,4,0,-5,10}

```text
首先把数组看成 : (6) 8 4 0 -5 10     ----> 其中括号中的数组表示有序数组
第一次插入: (6 8) 4 0 -5 10   ---> 对无序数组中的第一个数据进行插入
第二次插入: (4 6 8) 0 -5 10
第三次插入: (0 4 6 8) -5 10
第四次插入: (-5 0 4 6 8) 10
第五次插入: (-5 0 4 6 8 10)
```

#### 结论
交换次数依然是 数组长度-1   

#### 代码思路分析

* 首先需要区分出有序数组的部分
* 由上例,分析出每次有序数组大小都会+1,并且在开始插入时候就已经存在一个有序数组
* 所以外层循环从 1 到数组长度
* 内层循环从 i + 1 开始
* 借助辅助变量记录无序数组第一个数据,和无序数组的前一个数据下标(也就是有序数组的最后一个数据下标)
* 对需要插入的数与有序数组的数进行比较
    * 大于,说明就是插入在有序数组最后一个位置
    * 小于,先把当前插入数据的前一个数据后移,然后对前一个数据继续判断
* 当循环退出时候,说明找到插入位置,或者已经来到有序数组的第一个数据位置
* 再把辅助变量赋值给这个位置

```text
int insertVal = 0;
int insertIndex = 0;

for (int i = 1; i < arr.length; i++) {

    insertVal = arr[i];    // 接受需要插入的数据
    insertIndex = i - 1;   // 表示要插入数据的前一个数据下标

    //说明
    //  insertIndex - 1 > 0 保证下标不越界
    //  insertVal < arr[insertIndex] 当前要插入的值小于上一个值
    //  那就把上一个值后移一为
    while (insertIndex >= 0 && insertVal < arr[insertIndex]){
        arr[insertIndex + 1] = arr[insertIndex];   //后移操作
        insertIndex --;
    }
    //循环结束时候找到插入位置
    arr[insertIndex + 1] = insertVal;
}
```

#### 插入排序运行时间测试

首先定义了8万个随机数组成的数组
```text
int[] arr = new int[80000];
for (int i = 0; i < 80000; i++) {
    arr[i] = (int)(Math.random() * 80000);           //1-8万的随机数据存入数组
}
```

* 运行测试
    ```text
    第一次测试
    排序前的时间是 : 2020-02-28 23:03:35
    排序后的时间是 : 2020-02-28 23:03:35
    第二次测试
    排序前的时间是 : 2020-02-28 23:03:50
    排序后的时间是 : 2020-02-28 23:03:50
    第三次测试
    排序前的时间是 : 2020-02-28 23:03:59
    排序后的时间是 : 2020-02-28 23:03:59
    ```
* 插入排序对8万个数据进行排序,用时不到1秒

***

## **希尔排序**

说明 : 本质时插入排序的优化版本    
### 交换法

方法 : 对需要排序的数组排序,然后两两比较,进行交换
例如 : int[] arr = {6,8,4,0,-5,10}
```text
首先进行分组
            |-----|    
            6 8 4 0 -5 10
    这里增量为数组大小的半(5/2=2)
分组为6 和 0 一组 增量为3
分组为8 和 -5 一组 增量为3
分组为4 和 10 一组 增量为3

比较交换 : 0 -5 4 6 8 10
    继续交换,这是增量为原来增量的一半(3 / 2 = 1)
分组为 0 -5    
分组为 4 6    
分组为 8 10    

比较交换 : -5 0 4 6 8 10
```

#### 代码思路分析
* 首先需要定义增量循环```for(int gap = arr.length ; gap > 0 ; gap/=2)```
* 所分组的两个数据进行比较
* 两个数的下标差距为 gap

```text
for (int i = gap; i < arr.length; i++) {
    for (int j = i - gap; j >= 0; j -= gap) {
        // 对arr[0]和arr[3]的值进行比较
        if (arr[j] > arr[i]) {    // 前大于后的话就交换
            temp = arr[j];    // 交换
            arr[j] = arr[j + gap];
            arr[j + gap] = temp;
        }
    }
}
```

### 移动法
说明 : 由于交换法每次进入循环都会进行交换数,大大增加了算法时间
把插入排序与希尔排序进行了融合

#### 思路
(有待理解)

### 希尔排序运行时间测试(交换)

首先定义了8万个随机数组成的数组
```text
int[] arr = new int[80000];
for (int i = 0; i < 80000; i++) {
    arr[i] = (int)(Math.random() * 80000);           //1-8万的随机数据存入数组
}
```

* 运行测试
    ```text
    第一次测试
    排序前的时间是 : 2020-02-28 23:36:46
    排序后的时间是 : 2020-02-28 23:36:56
    第二次测试
    排序前的时间是 : 2020-02-28 23:37:05
    排序后的时间是 : 2020-02-28 23:37:13
    第三次测试
    排序前的时间是 : 2020-02-28 23:37:22
    排序后的时间是 : 2020-02-28 23:37:29
    ```
* 希尔交换排序对8万个数据进行排序,用时平均8秒

***
### 希尔排序运行时间测试(位移)

首先定义了8万个随机数组成的数组
```text
int[] arr = new int[80000];
for (int i = 0; i < 80000; i++) {
    arr[i] = (int)(Math.random() * 80000);           //1-8万的随机数据存入数组
}
```

* 运行测试
    ```text
    第一次测试
    排序前的时间是 : 2020-02-28 23:38:29
    排序后的时间是 : 2020-02-28 23:38:29
    第二次测试
    排序前的时间是 : 2020-02-28 23:38:38
    排序后的时间是 : 2020-02-28 23:38:38
    第三次测试
    排序前的时间是 : 2020-02-28 23:38:47
    排序后的时间是 : 2020-02-28 23:38:47
    ```
* 希尔位移排序对8万个数据进行排序,用时不到1秒

***
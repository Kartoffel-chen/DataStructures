DataStructures
==================================

该文件用来展现数据结构与算法的学习思路

****

|Autor|Kartoffel|
|:---:|:---:
|E-mail|1414524058@qq.com

****

## 目录

* [稀疏数组](#稀疏数组)

* [队列](#二.对列)
    * 队列
    * 环形队列
* [单向链表](#三.单向链表)
***

## 内容

### **稀疏数组**

#### 应用场景

```

模拟围棋的存盘和读盘
   例如 : 下为棋盘
          其中0代表围棋中没有下子的位置
          1表示白子
          2表示黑子
0    0    0    0    0    0    0    0    0    1    0    0    0    0    0    
0    0    1    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    1    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    2    0    0    0    0    0    0    0    
0    0    2    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0    
0    0    0    0    0    0    0    0    0    0    0    0    0    0    0 

```

#### 稀疏数组转换思路


1.存盘  
* 首先遍历棋盘得到有效值size(1或者2为有效值,代表有棋子的地方)  
* 创建大小为int[size + 1][3]
        1).稀疏数组创建规则
        2).第一行用来存放棋盘的[行数,列数,有效值个数]
        3).从第二行开始,用来存放有效值数据的信息[行坐标,列坐标,有效值]
* 将会得到下面的数组 例如 :

```
    12    15   5    ---> 代表棋盘的原本的行为12,列为15,期盼中有5个棋子
    0     9    1    ---> 代表原本棋盘的arr[0][9] = 1;
    1     2    1    ---> 同上
    5     6    1    
    6     7    2    
    7     2    2 
```
2.读盘   
* 首先遍历稀疏数组读取第一行的信息,对原本棋盘进行还原   
````
   例如 : 读取到 12 15 ,并且 int[][] test = new int[12][15];   
````
* 然后对以下行的数据进行对应还原   
````
   例如 : test[0][9] = 1;   
   例如 : test[6][7] = 2;   
````
***

### **二.对列**

#### 队列的应用场景
```

银行服务系统
例如:
    银行有5个柜台,能一次服务五个人
    银行最大能装人数
    每次服务结束,这个人退出银行,银行就能继续添加人进来(也可以不加)    

```

#### 队列思路分析
* 队列本身是有序列表
* 创建一个队列,接受最大容量(银行能服务多少人)
* 需要两个指针分别指向队列的头的前一个位置和尾巴
* 当往列表添加"人"的时候,尾巴向后移动一位
* 服务结束退出"人"的时候,把队列头的前一个位置指向第一个位置,输出
* 当头等于尾时,说明队列空了

#### 弊端   
此队列只能使用一次,应为我们的两个辅助指针并不会重复指向 0~最大服务数
,此时就引出了环形队列

### **环形队列**

#### 环形队列思路
* 在有序列表的基础上对头指针和尾指针进行改良
* 此时,我们的头指针都指向第一个元素,初始化为 front = 0
* 尾指针指向第一个元素的下一个元素,初始化也为 rear = 0
* 添加元素是,尾指针后移,并且做一个取模操作,保证rear能够回到原点    
````
    例如 : 队列的最大值为3
    添加第一个元素时,rear = (rear + 1) % 3 此时rear = 1;   
    添加第二个元素时,rear = (rear + 1) % 3 此时rear = 2;
    添加第三个元素时,rear = (rear + 1) % 3 此时rear = 3;
    添加第四个元素时,rear = (3 + 1) % 3 此时rear = 1;
    由此回到最开始的地方
````
* 取出元素同理由
* 当然,显示队列时候我们就应该从头指针指向的数据开始遍历,遍历结束条件是 if <有效数据
* 有效数据应该等于 (rear + maxsize - front) % maxsize
```
    例如 : 队列的最大值为3
    此时rear = 1 , front = 2;
    (1 + 3 - 2) % 3 = 2;
    有效数据就应该为2
```
* 循环条件就该写为for(i = front ; i < front + 2 ; i ++)
***

### **三.单向链表**

#### 创建链表
```
例如: 
    class Node{
        int id
        Node next;  ---> 指向下一个节点
    }
```

### 节点管理

#### 1.插入节点
* 在尾节点插入
    * 首先借助一个辅助指针,遍历这个链表,让指针指向链表的最后一个节点
    * 然后把最后一个节点的next域,指向新加入的节点
* 按照某一顺序插入(按照id大小排序)
    * 借助temp指针,遍历链表,当temp.next.id < newNode.id时候,说明就是添加到temp后
    * 把新增节点的next指向之前temp的next
    * 把temp的next指向新增节点

#### 2.修改节点信息
* 按照(id或其他修改)
    * 依然借助辅助指针遍历链表找到需要修改的链表,然后进行修改

#### 3.删除节点信息
* 按照(id或其他删除)
    * 依然借助辅助指针遍历链表找到需要删除的节点,此时的辅助指针应该指向下一个节点
    * 说明:当我们想要删除第三个数据时,我们的指针指向第二个节点,而指针的next刚好指向第三个节点,
    然后把第二个节点的下一个节点,指向第三个节点的下一个节点
    ```
        temp.next = temp.next.next;
    ```
